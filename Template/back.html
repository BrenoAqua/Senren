<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

<!-- BACK -->
<div class="back">

  <!-- HEADER -->
  <div class="header">

    <!-- Custom Dark Mode Toggle -->
    <span class="toggle-custom-dark-mode tappable">
      <i class="fas fa-sun sun-icon"></i>
      <i class="fas fa-moon moon-icon"></i>
    </span>

    <script>
      function darkMode() {
        const button = document.querySelector(".toggle-custom-dark-mode");
        const body = document.querySelector("html");
        const sunIcon = document.querySelector(".sun-icon");
        const moonIcon = document.querySelector(".moon-icon");

        const applyDarkMode = () => {
          const isDarkMode = localStorage.getItem("darkMode") === "enabled";
          body.classList.toggle("custom-dark-mode", isDarkMode);
          button.classList.toggle("dark-mode", isDarkMode);

          sunIcon.style.display = isDarkMode ? "inline" : "none";
          moonIcon.style.display = isDarkMode ? "none" : "inline";
        };

        requestAnimationFrame(applyDarkMode);

        button.addEventListener("click", () => {
          const isCurrentlyDark = body.classList.contains("custom-dark-mode");
          localStorage.setItem("darkMode", isCurrentlyDark ? "disabled" : "enabled");
          requestAnimationFrame(applyDarkMode);
        });
      }
      darkMode();
    </script>

    <!-- Audios -->
    {{#wordAudio}}
    <div class="{{Tags}}"><span class="audio">{{wordAudio}}</span></div>
    {{/wordAudio}}

    {{#sentenceAudio}}
    <div class="{{Tags}}"><span class="sentenceaudio">{{sentenceAudio}}</span></div>
    {{/sentenceAudio}}

    <!-- Notes Toggle -->
    {{#notes}}
    <span class="toggle-notes tappable">
      <div class="toggle-notes-svg"></div>
    </span>
    {{/notes}}

    <!-- Frequency Dropdown -->
    <div id="frequency">
      <div class="frequency-box tappable">
        <label class="freqbt">
          {{freqSort}} <i class="fas fa-chevron-down arrow"></i>
        </label>
        {{#frequency}}
        <div class="frequency-content">
          {{frequency}}
        </div>
        {{/frequency}}
      </div>
    </div>
    </div>

    <script>
      document.querySelectorAll('label.freqbt').forEach(lbl => {
        if (lbl.childNodes[0]?.nodeType === 3 && lbl.childNodes[0].nodeValue.trim() === "9999999")
          lbl.style.display = 'none';
      });
    </script>
  <!-- /HEADER -->

  <!-- GRID LAYOUT -->
  <div class="grid-container">

    <!-- Word -->
    <div class="background-box tappable">
      <div id="word" class="pitch card-a">
        <span class="{{pitch}} {{Tags}}">
          <ruby>{{word}}<rt>{{reading}}</rt></ruby>
          <div id="position">{{pitchPosition}}</div>
          <div id="categories" class="tappable">{{pitch}}</div>
        </span>
      </div>
    </div>

    <!-- Picture -->
    <div class="picture-container {{Tags}} clickable-image tappable">
      {{picture}}
      <div class="nav-arrow left tappable"></div>
      <div class="nav-arrow right tappable"></div>
    </div>
  </div>
  <!-- /GRID LAYOUT -->

  <!-- Lightbox -->
  <div class="lightbox" id="lightbox">
    <img id="lightbox-img">
    <a href="#" class="close tappable"></a>
    <div class="lightbox-nav left tappable"></div>
    <div class="lightbox-nav right tappable"></div>
    <button id="show-all" class="lightbox-grid-toggle tappable">Show All</button>
  </div>

  <!-- Sentence -->
  <div class="sentence-container">
    <div id="sentence">
      <span id="formattedSentence" class="{{pitch}} tappable"></span>
    </div>
    <div id="sentenceEng">
      {{sentenceEng}}
    </div>
  </div>

  <!-- Notes -->
  {{#notes}}
  <div class="notes is-collapsed">{{notes}}</div>
  {{/notes}}

  <!-- Selection Text -->
  {{#selectionText}}
  <div id="selectionText" class="card-b" data-type="selectionText">
    <div class="definition-box">
      <div class="dictionary-title">Selected Text</div>
      <div class="dictionary-counter"></div>
      <div class="toggle-area left-larger tappable"></div>
      <div class="toggle-area right-larger tappable"></div>
      <div class="toggle-area left tappable"></div>
      <div class="toggle-area right tappable"></div>
      <span>{{selectionText}}</span>
    </div>
  </div>
  {{/selectionText}}

  <!-- Definition -->
  <div id="definition" class="card-b" data-type="definition">
      <div class="dictionary-counter"></div>
      <div class="toggle-area left-larger tappable"></div>
      <div class="toggle-area right-larger tappable"></div>
      <div class="toggle-area left tappable"></div>
      <div class="toggle-area right tappable"></div>
    <div class="definition-box">

      <span>{{definition}}</span>
    </div>
  </div>

  <!-- Glossary -->
  <div id="glossary" class="card-b yomitan-glossary" data-type="glossary">
      <div class="dictionary-counter"></div>
      <div class="toggle-area left-larger tappable"></div>
      <div class="toggle-area right-larger tappable"></div>
      <div class="toggle-area left tappable"></div>
      <div class="toggle-area right tappable"></div>
    <div class="glossary-box">
      <span>{{glossary}}</span>
    </div>
  </div>

  <!-- FOOTER -->
  <div class="tags-and-links-wrapper">

    <!-- Tags -->
    <div class="tags-container"></div>

    <!-- External Links -->
    <div class="external-links">
      <!-- Jpdb -->
      <a data-details="jpdb.io" href="https://jpdb.io/search?q={{text:word}}">
        <img class="light-icon" src="_icon_jpdb_lightmode.png">
        <img class="dark-icon" src="_icon_jpdb_darkmode.png">
      </a>

      <!-- Jisho -->
      <a data-details="jisho.org" href="https://jisho.org/search/{{text:word}}">
        <img class="light-icon" src="_icon_jisho_lightmode.png">
        <img class="dark-icon" src="_icon_jisho_darkmode.png">
      </a>

      <!-- Google Images -->
      <a data-details="image_search" href="https://www.google.co.jp/search?q={{text:word}}&amp;tbm=isch">
        <img class="light-icon" src="_icon_image_black.svg">
        <img class="dark-icon" src="_icon_image_white.svg">
      </a>

      <!-- Nadeshiko -->
      <a data-details="nadeshiko.co" href="https://nadeshiko.co/search/sentence?query={{text:word}}">
        <img class="light-icon" src="_icon_nadeshiko.ico">
        <img class="dark-icon" src="_icon_nadeshiko.ico">
      </a>

      <!-- Immersion Kit -->
      <a data-details="immersionkit.com" href="https://immersionkit.com/dictionary?keyword={{text:word}}">
        <img class="light-icon" src="_icon_immersion_kit.ico">
        <img class="dark-icon" src="_icon_immersion_kit.ico">
      </a>
    </div>
  </div>

  <!-- Misc Info -->
  <div class="misc-info">
    {{miscInfo}}
  </div>
  <!-- /FOOTER -->

  <div id="dictionaryPreference" style="display: none;">{{dictionaryPreference}}</div>
  <div id="kanji-tooltip"></div>
</div>
<!-- /BACK -->

<script>
  // Helper functions for shortcuts
  function parseKeyConfig(configStr) {
    if (!configStr) return null;
    const parts = configStr.toLowerCase().split(/[\s+]+/).filter(p => p);
    if (parts.length === 0) return null;

    const key = parts.pop();
    return {
      key: key,
      ctrl: parts.includes('ctrl') || parts.includes('control'),
      alt: parts.includes('alt'),
      shift: parts.includes('shift'),
      meta: parts.includes('meta') || parts.includes('cmd')
    };
  }

  function isKeyMatch(event, config) {
    if (!config) return false;
    return (
      event.key.toLowerCase() === config.key &&
      event.ctrlKey === config.ctrl &&
      event.altKey === config.alt &&
      event.shiftKey === config.shift &&
      event.metaKey === config.meta
    );
  }

  // Collect images from the glossary and add them to the picture container
  function collectGlossaryImages() {
    const glossaryItems = document.querySelectorAll("#glossary img");
    const pictureContainer = document.querySelector(".picture-container");

    if (!glossaryItems.length || !pictureContainer) return;

    const computedStyles = window.getComputedStyle(document.documentElement);
    const collectSetting = computedStyles.getPropertyValue('--collect-glossary-images').trim().toLowerCase();

    if (collectSetting !== 'true') {
      return;
    }

    glossaryItems.forEach(img => {
      if (!img.src ||
        img.src === window.location.href ||
        img.src.toLowerCase().endsWith('.svg') ||
        img.closest('span[data-sc-pixiv="read-more-link"] a') ||
        img.closest(`
          [data-dictionary*="漢字でGo!"],
          [data-dictionary*="現代国語例解辞典"]
        `)
      ) {
        return;
      }

      const aspectRatio = img.naturalWidth / img.naturalHeight;
      const tooTall = aspectRatio < 0.7;
      const tooSmall = img.naturalWidth < 120 || img.naturalHeight < 180;

      if (img.naturalHeight > 0 && (tooTall || tooSmall)) {
        return;
      }

      const newImg = new Image();
      newImg.src = img.src;
      newImg.loading = "lazy";

      newImg.onload = () => {

        const w = newImg.naturalWidth;
        const h = newImg.naturalHeight;
        const finalAspectRatio = w / h;

        if (w < 120 || h < 180 || finalAspectRatio < 0.7 || finalAspectRatio > 1.6) {
          return;
        } else {
          newImg.classList.add('tappable');
        }
      };

      pictureContainer.appendChild(newImg);
    });
  }

  // Manages cycling between Selection Text, Definition, and Glossary
  function toggleDefinition() {
    const toggleAreas = document.querySelectorAll('.toggle-area');
    const selectionText = document.getElementById('selectionText');
    const definition = document.getElementById('definition');
    const glossary = document.getElementById('glossary');
    const allGlossaryListItems = Array.from(document.querySelectorAll("#glossary > .glossary-box > span > div li[data-dictionary], #glossary > div > span > div > i"));
    const dictionaryPreference = document.getElementById('dictionaryPreference')?.textContent.trim() || '';

    function updateBackgroundColor(element) {
      const backDiv = document.querySelector('.back');
      if (!backDiv || !element) return;

      const computed = getComputedStyle(element);
      const color = computed.getPropertyValue('--dict-color').trim();
      const rgb = computed.getPropertyValue('--dict-color-rgb').trim();

      if (color) backDiv.style.setProperty('--dict-color', color);
      if (rgb) backDiv.style.setProperty('--dict-color-rgb', rgb);
    }

    function getDictionaryName(element) {
      if (element.tagName === 'LI' && element.hasAttribute('data-dictionary')) {
        return element.getAttribute('data-dictionary');
      }
      return null;
    }

    const hasSelectionText = !!selectionText && selectionText.textContent.trim() !== '';
    const hasDefinition = !!definition && definition.textContent.trim() !== '';
    let definitionDictName = null;

    if (hasDefinition) {
      const definitionLi = definition.querySelector('.definition-box li[data-dictionary]');
      if (definitionLi) {
        definitionDictName = definitionLi.getAttribute('data-dictionary');
      }
    }

    const visibleGlossaryItems = allGlossaryListItems.filter(li => {
      const parentDiv = li.closest('div');
      if (parentDiv && parentDiv.classList.contains('ignore')) {
        return false;
      }

      if (hasDefinition && definitionDictName) {
        const glossaryDictName = getDictionaryName(li);
        if (glossaryDictName && glossaryDictName === definitionDictName) {
          return false;
        }
      }
      return true;
    });

    const currentVisibleItems = [];
    if (hasSelectionText) currentVisibleItems.push({ type: 'selectionText', element: selectionText, container: selectionText });
    if (hasDefinition) {
      const defLi = definition.querySelector('.definition-box li[data-dictionary]');
      currentVisibleItems.push({ 
        type: 'definition', 
        element: defLi || definition,
        container: definition 
      });
    }

    if (visibleGlossaryItems.length > 0) {
      visibleGlossaryItems.forEach((li) => {
        currentVisibleItems.push({ type: 'glossary', element: li, container: glossary });
      });
    }

    const totalVisibleItemsCount = currentVisibleItems.length;

    toggleAreas.forEach(area => {
      if (totalVisibleItemsCount <= 1) {
        area.style.display = 'none';
      } else {
        area.style.display = '';
      }
    });

    function updateCounters(activeIndex) {
      const counterText = totalVisibleItemsCount > 0 ? `${activeIndex + 1} / ${totalVisibleItemsCount}` : '';

      [selectionText, definition, glossary].forEach(container => {
        if (container) {
          const counterDiv = container.querySelector('.dictionary-counter');
          if (counterDiv) {
            counterDiv.textContent = '';
          }
        }
      });

      if (activeIndex !== -1 && totalVisibleItemsCount > 0) {
        const activeItem = currentVisibleItems[activeIndex];
        if (activeItem && activeItem.container) {
          const activeCounterDiv = activeItem.container.querySelector('.dictionary-counter');
          if (activeCounterDiv) {
            activeCounterDiv.textContent = counterText;
          }
        }
      }
    }

    function getCurrentIndex() {
      let activeIndex = -1;
      if (selectionText && selectionText.classList.contains('show')) {
        activeIndex = currentVisibleItems.findIndex(item => item.type === 'selectionText');
      } else if (definition && definition.classList.contains('show')) {
        activeIndex = currentVisibleItems.findIndex(item => item.type === 'definition');
      } else if (glossary && glossary.classList.contains('show')) {
        const currentGlossaryLi = visibleGlossaryItems.find(li => li.style.display === 'block');
        if (currentGlossaryLi) {
          activeIndex = currentVisibleItems.findIndex(item => item.type === 'glossary' && item.element === currentGlossaryLi);
        } else if (currentVisibleItems.some(item => item.type === 'glossary')) {
          activeIndex = currentVisibleItems.findIndex(item => item.type === 'glossary');
        }
      }
      return activeIndex;
    }

    function getDictionaryMap() {
      const map = new Map();
      allGlossaryListItems.forEach(li => {
        const dictionaryName = getDictionaryName(li);
        if (dictionaryName) {
          map.set(dictionaryName, li);
        }
      });
      return map;
    }

    let initialIndex = -1;

    allGlossaryListItems.forEach(li => (li.style.display = 'none'));
    if (selectionText) selectionText.classList.remove('show');
    if (definition) definition.classList.remove('show');
    if (glossary) glossary.classList.remove('show');

    if (totalVisibleItemsCount > 0) {
      const permanentLastSelected = localStorage.getItem("lastSelectedDictionary");
      const permanentDictionaryName = localStorage.getItem("lastDictionaryName");
      const dictionaryMap = getDictionaryMap();
      let initialStateSet = false;

      if (!initialStateSet) {

        // Priority 1: Selection Text
        if (hasSelectionText) {
          initialIndex = currentVisibleItems.findIndex(item => item.type === 'selectionText');
          if (initialIndex !== -1) {
            initialStateSet = true;
          }
        }

        // Priority 2: Local Storage
        if (!initialStateSet && permanentLastSelected === "glossary" && visibleGlossaryItems.length > 0) {
          let foundDictionaryFromStorage = false;
          if (permanentDictionaryName && dictionaryMap.has(permanentDictionaryName)) {
            const specificLiElement = dictionaryMap.get(permanentDictionaryName);
            if (visibleGlossaryItems.includes(specificLiElement)) {
              initialIndex = currentVisibleItems.findIndex(item => item.type === 'glossary' && item.element === specificLiElement);
              if (initialIndex !== -1) {
                specificLiElement.style.display = 'block';
                foundDictionaryFromStorage = true;
                initialStateSet = true;
              }
            }
          }

          // fallback
          if (!foundDictionaryFromStorage) {
            initialIndex = currentVisibleItems.findIndex(item => item.type === 'glossary');
            if (initialIndex !== -1) {
              currentVisibleItems[initialIndex].element.style.display = 'block';
              initialStateSet = true;
            }
          }
        }

        // Priority 3: Dictionary Preference
        if (!initialStateSet && dictionaryPreference && visibleGlossaryItems.length > 0) {
          const lowerCasePref = dictionaryPreference.toLowerCase();

          if (lowerCasePref === 'glossary') {
            // Preference is "glossary", show the first available one
            initialIndex = currentVisibleItems.findIndex(item => item.type === 'glossary');
            if (initialIndex !== -1) {
              currentVisibleItems[initialIndex].element.style.display = 'block';
              initialStateSet = true;
            }
          } else if (dictionaryMap.has(dictionaryPreference)) {
            // Preference is a specific dictionary name
            const preferredLiElement = dictionaryMap.get(dictionaryPreference);
            if (visibleGlossaryItems.includes(preferredLiElement)) {
              initialIndex = currentVisibleItems.findIndex(item => item.type === 'glossary' && item.element === preferredLiElement);
              if (initialIndex !== -1) {
                preferredLiElement.style.display = 'block';
                initialStateSet = true;
              }
            }
          }
        }

        // Priority 4: Definition
        if (!initialStateSet && hasDefinition) {
          initialIndex = currentVisibleItems.findIndex(item => item.type === 'definition');
          if (initialIndex !== -1) {
            initialStateSet = true;
          }
        }

        // Priority 5: Glossary
        if (!initialStateSet && visibleGlossaryItems.length > 0) {
          initialIndex = currentVisibleItems.findIndex(item => item.type === 'glossary');
          if (initialIndex !== -1) {
            currentVisibleItems[initialIndex].element.style.display = 'block';
            initialStateSet = true;
          }
        }

        if (!initialStateSet) {
          if (currentVisibleItems.length > 0) initialIndex = 0;
        }
      }

      if (initialIndex !== -1) {
        const initialItem = currentVisibleItems[initialIndex];
        if (initialItem.container) {
          initialItem.container.classList.add('show');
          // For collapsed dictionary entries 1
          collapseDictionary(initialItem.container.querySelector('.definition-box, .glossary-box'));
          // For dictionary colorizer 1
          updateBackgroundColor(initialItem.element);
        }
      }
    }

    updateCounters(initialIndex);

    const handleToggle = (direction) => {
      const currentIndex = getCurrentIndex();
      if (currentIndex === -1 || totalVisibleItemsCount <= 1) return;

      const currentItem = currentVisibleItems[currentIndex];
      if (currentItem.type === 'selectionText' || currentItem.type === 'definition') {
        if (currentItem.container) currentItem.container.classList.remove('show');
      } else if (currentItem.type === 'glossary') {
        currentItem.element.style.display = 'none';
      }

      let nextIndex;
      if (direction === 'right') {
        nextIndex = (currentIndex + 1) % totalVisibleItemsCount;
      } else {
        nextIndex = (currentIndex - 1 + totalVisibleItemsCount) % totalVisibleItemsCount;
      }

      const nextItem = currentVisibleItems[nextIndex];

      if (currentItem.type === 'glossary' && nextItem.type !== 'glossary') {
        if (currentItem.container) currentItem.container.classList.remove('show');
      }

      if (nextItem.type === 'selectionText' || nextItem.type === 'definition') {
        if (nextItem.container) nextItem.container.classList.add('show');
      } else if (nextItem.type === 'glossary') {
        if (nextItem.container) nextItem.container.classList.add('show');
        nextItem.element.style.display = 'block';
      }

      // For collapsed dictionary entries 2
      collapseDictionary(nextItem.container.querySelector('.definition-box, .glossary-box'));
      // For collapsed dictionary colorizer 2
      updateBackgroundColor(nextItem.element);

      if (nextItem.type === 'selectionText') {
        localStorage.setItem("lastSelectedDictionary", "selectionText");
        localStorage.removeItem("lastDictionaryName");
      } else if (nextItem.type === 'definition') {
        localStorage.setItem("lastSelectedDictionary", "definition");
        localStorage.removeItem("lastDictionaryName");
      } else if (nextItem.type === 'glossary') {
        localStorage.setItem("lastSelectedDictionary", "glossary");
        const dictionaryName = getDictionaryName(nextItem.element);
        if (dictionaryName) {
          localStorage.setItem("lastDictionaryName", dictionaryName);
        } else {
          localStorage.removeItem("lastDictionaryName");
        }
      }

      updateCounters(nextIndex);

      const backElement = document.querySelector('.back');
      if (backElement && !backElement.classList.contains('dict-toggled-once')) {
        backElement.classList.add('dict-toggled-once');
      }
    };

    toggleAreas.forEach(area => {
      area.addEventListener('click', (e) => {
        if (totalVisibleItemsCount <= 1) return;

        if (area.classList.contains('right') || area.classList.contains('right-larger')) {
          handleToggle('right');
        } else if (area.classList.contains('left') || area.classList.contains('left-larger')) {
          handleToggle('left');
        }
      });
    });

    document.addEventListener('keydown', (e) => {
      if (totalVisibleItemsCount <= 1) return;
      if (e.ctrlKey) return; 

      if (typeof lightbox !== 'undefined' && lightbox.classList.contains('active')) return;
      if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) {
        return;
      }
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        handleToggle('left');
      }
      if (e.key === 'ArrowRight') {
        e.preventDefault();
        handleToggle('right');
      }
    });
  }

  // Adds hover effects to Jitendex dictionary content 
  function jitendexHover() {
    const sentencePairs = document.querySelectorAll('[data-sc-content="example-sentence-a"]');
    const xrefPairs = document.querySelectorAll('[data-sc-content="xref"]');
    const antonymPairs = document.querySelectorAll('[data-sc-content="antonym"]');
    const notePairs = document.querySelectorAll('[data-sc-content="sense-note"]');
    const explanationPairs = document.querySelectorAll('[data-sc-content="info-gloss"]');
    const langPairs = document.querySelectorAll('[data-sc-content="lang-source"]');

    const handleHover = (parentElement, elementB) => {
      if (parentElement && elementB) {
        parentElement.classList.add('tappable');
        parentElement.style.opacity = '0.5';
        parentElement.style.transition = 'opacity 0.3s ease';
        elementB.style.maxHeight = '0';
        elementB.style.overflow = 'hidden';
        elementB.style.transition = 'max-height 0.3s ease, opacity 0.3s ease';
        elementB.style.display = 'block';

        const showContent = () => {
          requestAnimationFrame(() => {
            parentElement.style.opacity = '1';
            elementB.style.maxHeight = elementB.scrollHeight + 'px';
            elementB.style.opacity = '1';
          });
        };

        const hideContent = () => {
          requestAnimationFrame(() => {
            parentElement.style.opacity = '0.5';
            elementB.style.maxHeight = '0';
            elementB.style.opacity = '0';
          });
        };

        elementB.addEventListener('mouseover', showContent);
        parentElement.addEventListener('mouseover', showContent);

        elementB.addEventListener('mouseout', hideContent);
        parentElement.addEventListener('mouseout', hideContent);
      }
    };

    sentencePairs.forEach(sentenceA => {
      const sentenceB = sentenceA.nextElementSibling;
      if (sentenceA && sentenceB) {
        sentenceA.classList.add('tappable');
        sentenceA.style.opacity = '0.5';
        sentenceA.style.transition = 'opacity 0.3s ease';
        sentenceA.style.cursor = 'pointer';
        sentenceB.style.maxHeight = '0';
        sentenceB.style.overflow = 'hidden';
        sentenceB.style.transition = 'max-height 0.3s ease, opacity 0.3s ease';
        sentenceB.style.display = 'block';
        sentenceB.style.opacity = '0';

        let isSentenceBVisible = false;

        sentenceA.addEventListener('click', (event) => {
          event.stopPropagation();
          isSentenceBVisible = !isSentenceBVisible;

          const sentenceContainer = sentenceA.closest('[data-sc-content="example-sentence"]');

          requestAnimationFrame(() => {
            if (isSentenceBVisible) {
              sentenceA.style.opacity = '1';
              sentenceB.style.maxHeight = sentenceB.scrollHeight + 'px';
              sentenceB.style.opacity = '1';

              if (sentenceContainer) {
                sentenceContainer.classList.add('sentence-active');
              }

            } else {
              if (!sentenceA.matches(':hover')) {
                sentenceA.style.opacity = '0.5';
              }
              sentenceB.style.maxHeight = '0';
              sentenceB.style.opacity = '0';

              if (sentenceContainer) {
                sentenceContainer.classList.remove('sentence-active');
              }
            }
          });
        });

        sentenceA.addEventListener('mouseenter', () => {
          sentenceA.style.opacity = '1';
        });

        sentenceA.addEventListener('mouseleave', () => {
          if (!isSentenceBVisible) {
            sentenceA.style.opacity = '0.5';
          }
        });

      }
    });

    xrefPairs.forEach(xref => {
      const xrefGlossary = xref.querySelector('[data-sc-content="xref-glossary"]');
      handleHover(xref, xrefGlossary);
    });

    antonymPairs.forEach(antonym => {
      const antonymGlossary = antonym.querySelector('[data-sc-content="antonym-glossary"]');
      handleHover(antonym, antonymGlossary);
    });

    notePairs.forEach(note => {
      const noteGlossary = note.querySelector('div:last-child');
      handleHover(note, noteGlossary);
    });

    explanationPairs.forEach(explanation => {
      const infoGloss = explanation.querySelector('div:last-child');
      handleHover(explanation, infoGloss);
    });

    langPairs.forEach(lang => {
      const langSource = lang.querySelector('div:last-child');
      handleHover(lang, langSource);
    });
  }

  // Enables interaction effects
  function enableInteractions() {

    function applyClickToggleEffect(triggerSelector, targetSelector, extraPadding = 0) {
      const trigger = document.querySelector(triggerSelector);
      const target = document.querySelector(targetSelector);

      if (trigger && target) {
        const clickable = 'is-clickable';

        if (target.textContent.trim() !== "") {
          trigger.classList.add(clickable);
        } else {
          trigger.classList.remove(clickable);
        }

        trigger.addEventListener("click", () => {
          if (!trigger.classList.contains(clickable)) {
            return;
          }

          requestAnimationFrame(() => {
            const isCollapsed = !target.style.maxHeight || target.style.maxHeight === "0px";

            if (isCollapsed) {
              target.classList.remove("is-collapsed");
              target.style.maxHeight = target.scrollHeight + extraPadding + "px";
              if (extraPadding) {
                target.style.opacity = "1";
                target.style.paddingTop = extraPadding + "px";
              }
            } else {
              target.classList.add("is-collapsed");
              target.style.maxHeight = "0";
              if (extraPadding) {
                target.style.opacity = "0";
                target.style.paddingTop = "0px";
              }
            }
          });
        });
      }
    }

    function applyHoverEffect(containerSelector, targetSelector, extraPadding = 0) {
      const container = document.querySelector(containerSelector);
      const target = document.querySelector(targetSelector);

      if (container && target) {

        if (window.matchMedia("(pointer: coarse)").matches) {
          container.classList.add('tappable');
        }

        container.addEventListener("mouseenter", () => {
          requestAnimationFrame(() => {
            if (target.textContent.trim() !== "") {
              target.style.maxHeight = target.scrollHeight + extraPadding + "px";
              if (extraPadding) {
                target.style.opacity = "1";
                target.style.paddingTop = extraPadding + "px";
              }
            } else {
              target.style.maxHeight = "0";
              if (extraPadding) {
                target.style.opacity = "0";
                target.style.paddingTop = "0px";
              }
            }
          });
        });

        container.addEventListener("mouseleave", () => {
          requestAnimationFrame(() => {
            target.style.maxHeight = "0";
            if (extraPadding) {
              target.style.opacity = "0";
              target.style.paddingTop = "0px";
            }
          });
        });
      }
    }

    const notesElement = document.querySelector('.back .notes');

    if (notesElement) {
      const expandByDefault = getComputedStyle(document.documentElement)
                              .getPropertyValue('--notes-default-expanded').trim();

      if (expandByDefault === 'true') {
        const originalTransition = notesElement.style.transition;
        notesElement.style.transition = 'none';

        if (notesElement.classList.contains('is-collapsed')) {
          notesElement.classList.remove('is-collapsed');
          notesElement.style.maxHeight = notesElement.scrollHeight + 'px';
        }
      }
    }

    applyClickToggleEffect("#formattedSentence", "#sentenceEng");
    applyClickToggleEffect(".toggle-notes", ".notes");

    const isTouchDevice = window.matchMedia("(pointer: coarse)").matches;
    const pictureHoverTriggerSelector = isTouchDevice ? ".background-box" : ".picture-container";
    applyHoverEffect(pictureHoverTriggerSelector, ".misc-info", 20);
  }

  // Allows cycling through images
  function enableImageSwitching() {
    let currentImageIndex = 0;

    function switchImage(direction, event) {
      if (event) event.preventDefault();
      if (event) event.stopPropagation();

      const images = document.querySelectorAll('.picture-container img');
      if (images.length === 0) return;

      const visibleIndex = Array.from(images).findIndex(img => {
          return window.getComputedStyle(img).display !== 'none';
      });
      
      if (visibleIndex !== -1) currentImageIndex = visibleIndex;

      images.forEach(img => img.style.setProperty('display', 'none', 'important'));

      currentImageIndex += direction;

      if (currentImageIndex >= images.length) {
        currentImageIndex = 0;
      } else if (currentImageIndex < 0) {
        currentImageIndex = images.length - 1;
      }

      images[currentImageIndex].style.setProperty('display', 'block', 'important');
    }

    const arrows = document.querySelectorAll('.nav-arrow');
    const images = document.querySelectorAll('.picture-container img');

    if (images.length <= 1) {
      arrows.forEach(arrow => arrow.classList.add('hidden'));
    } else {
      arrows.forEach(arrow => arrow.classList.remove('hidden'));
    }

    arrows.forEach(arrow => {
      arrow.addEventListener('click', (event) => {
        const direction = arrow.classList.contains('left') ? -1 : 1;
        switchImage(direction, event);
      });
    });
  }

  // Creates lightbox for image viewing
  function enableLightbox() {
    const images = document.querySelectorAll(".picture-container img");
    if (!images.length) return;

    let currentIndex = 0;
    let scale = 1, translateX = 0, translateY = 0;
    let isPanning = false, startX = 0, startY = 0;
    let isGridView = false;

    const lightbox = document.getElementById("lightbox");
    const lightboxImg = document.getElementById("lightbox-img");
    const leftButton = document.querySelector(".lightbox-nav.left");
    const rightButton = document.querySelector(".lightbox-nav.right");
    const showAll = document.getElementById("show-all");

    if (images.length <= 1) {
      leftButton.classList.add("hidden");
      rightButton.classList.add("hidden");
      showAll.remove();
    } else {
      leftButton.classList.remove("hidden");
      rightButton.classList.remove("hidden");
    }

    function showGridView() {
      isGridView = true;
      const gridContainer = document.createElement("div");
      gridContainer.className = "lightbox-grid";

      images.forEach((img, index) => {
        const gridImg = document.createElement("img");
        gridImg.src = img.src;
        gridImg.alt = `Image ${index + 1}`;
        gridImg.classList.add('tappable');
        gridImg.addEventListener("click", () => {
          showImage(index);
          hideGridView();
        });
        gridContainer.appendChild(gridImg);
      });

      const imgCount = images.length;
      if (imgCount <= 4) {
        gridContainer.style.gridTemplateColumns = `repeat(${imgCount}, 1fr)`;
      } else if (imgCount <= 9) {
        gridContainer.style.gridTemplateColumns = "repeat(3, 1fr)";
      } else {
        gridContainer.style.gridTemplateColumns = "repeat(4, 1fr)";
      }

      lightbox.appendChild(gridContainer);
      lightboxImg.style.display = "none";
      leftButton.style.display = "none";
      rightButton.style.display = "none";
      showAll.textContent = "Back";
    }

    function hideGridView() {
      isGridView = false;
      const grid = document.querySelector(".lightbox-grid");
      if (grid) {
        grid.remove();
      }
      lightboxImg.style.display = "block";
      leftButton.style.display = "";
      rightButton.style.display = "";
      showAll.textContent = "Show All";
    }

    const showImage = (index) => {
      if (isGridView) hideGridView();
      currentIndex = index;
      lightboxImg.src = images[index].src;
      resetTransform();
      showAll.style.display = "block";
      lightbox.classList.add("active");
    };

    const resetTransform = () => {
      scale = 1;
      translateX = 0;
      translateY = 0;
      updateTransform();
    };

    const updateTransform = () => {
      lightboxImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    };

    images.forEach((img, index) => {
      const container = img.closest('.picture-container');
      const isNSFW = container && container.className.toLowerCase().includes('nsfw');

      if (isNSFW) {
        img.addEventListener("click", (e) => {
          if (img.classList.contains('clicked')) {
            showImage(index);
          } else {
            img.classList.add('clicked');
          }
        });
      } else {
        img.addEventListener("click", () => showImage(index));
      }
    });

    showAll.addEventListener("click", (e) => {
      e.stopPropagation();
      if (isGridView) {
        hideGridView();
      } else {
        showGridView();
      }
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (isGridView) {
          hideGridView();
        } else {
          lightbox.classList.remove("active");
        }
      }

      if (lightbox.classList.contains("active") && !isGridView) {
        if (e.key === "ArrowLeft") {
          showImage(currentIndex = (currentIndex > 0) ? currentIndex - 1 : images.length - 1);
        }
        if (e.key === "ArrowRight") {
          showImage(currentIndex = (currentIndex < images.length - 1) ? currentIndex + 1 : 0);
        }
      }
    });

    lightboxImg.addEventListener("wheel", (e) => {
      e.preventDefault();
      const prevScale = scale;
      scale = Math.min(Math.max(1, scale + e.deltaY * -0.001), 3);

      if (scale === 1) {
        resetTransform();
        showAll.style.display = "block";
      } else {
        const rect = lightboxImg.getBoundingClientRect();
        const offsetX = (e.clientX - rect.left) / rect.width;
        const offsetY = (e.clientY - rect.top) / rect.height;
        translateX -= (offsetX - 0.5) * (scale - prevScale) * rect.width;
        translateY -= (offsetY - 0.5) * (scale - prevScale) * rect.height;
        updateTransform();
        showAll.style.display = "none";
      }
    });

    lightboxImg.addEventListener("mousedown", (e) => {
      if (scale === 1) return;
      e.preventDefault();
      isPanning = true;
      startX = e.clientX - translateX;
      startY = e.clientY - translateY;
      lightboxImg.style.cursor = "grabbing";
    });

    let initialDistance = null;

    lightboxImg.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        initialDistance = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY
        );
        isPanning = false;
      } else if (e.touches.length === 1 && scale > 1) {
        isPanning = true;
        startX = e.touches[0].pageX - translateX;
        startY = e.touches[0].pageY - translateY;
        initialDistance = null;
      } else {
        isPanning = false;
        initialDistance = null;
      }
    });

    lightboxImg.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && initialDistance !== null) {
        e.preventDefault();
        const newDistance = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY
        );
        const newScale = scale * (newDistance / initialDistance);
        const prevScale = scale;

        scale = Math.min(Math.max(1, newScale), 3);

        if (scale > 1) {
          const rect = lightboxImg.getBoundingClientRect();
          const touchCenterX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
          const touchCenterY = (e.touches[0].pageY + e.touches[1].pageY) / 2;

          const offsetX = (touchCenterX - rect.left) / rect.width;
          const offsetY = (touchCenterY - rect.top) / rect.height;

          translateX -= (offsetX - 0.5) * (scale - prevScale) * rect.width;
          translateY -= (offsetY - 0.5) * (scale - prevScale) * rect.height;

          updateTransform();
          showAll.style.display = "none";
        } else {
          resetTransform();
          showAll.style.display = "block";
        }
        initialDistance = newDistance;

      } else if (e.touches.length === 1 && isPanning) {
        e.preventDefault();
        translateX = e.touches[0].pageX - startX;
        translateY = e.touches[0].pageY - startY;
        updateTransform();
      }
    });

    lightboxImg.addEventListener('touchend', (e) => {
      if (e.touches.length < 2) {
        initialDistance = null;
      }
      if (e.touches.length < 1) {
        isPanning = false;
      }
    });

    const moveImage = (e) => {
      if (!isPanning) return;
      translateX = e.clientX - startX;
      translateY = e.clientY - startY;
      updateTransform();
    };

    document.addEventListener("mousemove", (e) => {
      if (isPanning) requestAnimationFrame(() => moveImage(e));
    });

    document.addEventListener("mouseup", () => {
      isPanning = false;
      lightboxImg.style.cursor = "grab";
    });

    lightbox.addEventListener("click", (e) => {
      if (e.target === lightbox ||
        (isGridView && !e.target.closest('.lightbox-grid img') && e.target !== showAll)) {
        if (isGridView) {
          lightbox.classList.remove("active");
        } else {
          lightbox.classList.remove("active");
        }
      }
    });

    lightbox.addEventListener("touchend", (e) => {
      if (e.target === lightbox ||
        (isGridView && !e.target.closest('.lightbox-grid img') && e.target !== showAll)) {
        if (isGridView) {
          lightbox.classList.remove("active");
        } else {
          lightbox.classList.remove("active");
        }
      }
    });

    leftButton.addEventListener("click", () => {
      showImage(currentIndex = (currentIndex > 0) ? currentIndex - 1 : images.length - 1);
    });

    rightButton.addEventListener("click", () => {
      showImage(currentIndex = (currentIndex < images.length - 1) ? currentIndex + 1 : 0);
    });
  }

  // Adjusts word size based on character length
  function dynamicWordSize() {
    const wordElement = document.querySelector("#word");
    if (wordElement) {
      const wordSpan = wordElement.querySelector('span');
      if (wordSpan) {
        const rubyElement = wordSpan.querySelector('ruby');
        const content = rubyElement ? rubyElement.firstChild.textContent.trim() : wordSpan.textContent.trim();
        const contentLength = content.length;

        const classNumber = Math.min(contentLength, 9);
        wordElement.classList.add(`length-${classNumber}`);
      }
    }
  }

  // Enables NSFW options
  function nsfw() {
    const tags = `{{Tags}}`.toLowerCase();
    const isNsfwCard = tags.includes('nsfw');

    const muteNsfw = getComputedStyle(document.documentElement)
      .getPropertyValue('--mute-nsfw-audio')
      .trim()
      .toLowerCase();

    if (isNsfwCard && muteNsfw === 'true') {

      const wordAudioButton = document.querySelector(".audio .soundLink, .audio .replaybutton");
      if (wordAudioButton) {
        wordAudioButton.click();
      }

      document.querySelectorAll('.picture-container').forEach(container => {
        if (container.classList.contains('nsfw')) {
          container.querySelectorAll('img').forEach(img => {
            img.addEventListener('click', () => {
              img.classList.add('clicked');
            });
          });
        }
      });
    }
  }

  // Mutes the sentence audio playback based on CSS variables
  function muteSentence() {
    // Get the value of the CSS variable
    const muteAudio = getComputedStyle(document.documentElement)
      .getPropertyValue('--mute-sentence-audio')
      .trim()
      .toLowerCase();

    if (muteAudio === 'true') {
      const wordAudioButton = document.querySelector(".audio .soundLink, .audio .replaybutton");
    
      if (wordAudioButton) {
        wordAudioButton.click();
      }
    }
  }  
  
  // Adds titles to dictionaries
  function dictionaryTitle() {
    let processedDictionaries = new Set();

    document.querySelectorAll('.yomitan-glossary li').forEach(li => {
      let dictionaryName = li.getAttribute('data-dictionary');
      if (dictionaryName && !processedDictionaries.has(dictionaryName)) {
        let titleElement = document.createElement('div');
        titleElement.textContent = dictionaryName;
        titleElement.classList.add('dictionary-title');
        li.prepend(titleElement);
        processedDictionaries.add(dictionaryName);
      }
    });
  }

  // Splits tags into separate elements
  function splitTags() {
    const tagsContainer = document.querySelector(".tags-container");
    if (tagsContainer) {
      tagsContainer.innerHTML = "";
      const tags = `{{Tags}}`.split(" ");
      tags.forEach(tag => {
        const tagElem = document.createElement("div");
        tagElem.className = "tags";
        tagElem.innerText = tag;
        tagsContainer.appendChild(tagElem);
      });
    }
  }

  // Kanji Hover
  var ankiConnectUrl = "http://localhost:8765";
  var tooltipElement = document.getElementById("kanji-tooltip");
  var hideTooltipTimeout;
  var preloadedKanjiData = {};

  function isKanji(char) {
    return /[一-龯㐀-䶿]/.test(char);
  }

  // Helper function to draw the pitch downstep (fallback)
  function drawTooltipPitchLines(tooltip) {
    if (!tooltip) return;

    const moraRegexParts = [
      '[きしちにひみりぎじぢびぴゔ][ゃゅょ]', '[うくすつぬふむゆるぐずづぶゔ][ぁぃぅぇぉ]',
      '[てで][ぃ]', '[とど][ぅ]', '[キシチニヒミリギジヂビピヴ][ャュョ]',
      '[ウクスツヌフムユルグズヅブプヴ][ァィゥェォ]', '[テデ][ィ]', '[トド][ゥ]',
      '[クグ][ヮ]', '[フ][ォ]', '[っッ]', 'ー', '[んン]',
      '[\u3041-\u3096\u30A1-\u30F6\u30FD\u30FE]', '\\S'
    ];
    const moraRegex = new RegExp(moraRegexParts.join('|'), 'g');

    const entries = tooltip.querySelectorAll('li');

    entries.forEach(li => {
      const rt = li.querySelector('rt');
      const numberSpan = li.querySelector('.pitch-number');
      
      if (!rt || !numberSpan) return;
      if (rt.querySelector('.pronunciation')) return; 

      const readingText = rt.textContent.trim();
      const morae = readingText.match(moraRegex) || [];
      const moraCount = morae.length;
      if (moraCount === 0) return;

      const pitchNum = parseInt(numberSpan.textContent.trim(), 10);
      if (isNaN(pitchNum)) return;

      let pattern = [];
      for (let i = 0; i < moraCount; i++) {
        if (pitchNum === 0) {
           pattern.push(i === 0 ? 'L' : 'H');
        } else if (pitchNum === 1) {
           pattern.push(i === 0 ? 'H' : 'L');
        } else { 
           if (i === 0) pattern.push('L');
           else if (i < pitchNum) pattern.push('H');
           else pattern.push('L');
        }
      }

      let pClass = 'heiban';
      if (pitchNum === 1) pClass = 'atamadaka';
      else if (pitchNum === 0) pClass = 'heiban';
      else if (pitchNum === moraCount) pClass = 'odaka';
      else pClass = 'nakadaka';

      const container = document.createElement('span');
      container.className = `pronunciation ${pClass}`;

      for (let i = 0; i < moraCount; i++) {
        const type = pattern[i] === 'H' ? 'high' : 'low';
        const span = document.createElement('span');
        span.className = 'pronunciation-mora';
        span.textContent = morae[i];
        span.dataset.pitch = type;

        if (type === 'high') {
          if ((i + 1 < moraCount && pattern[i+1] === 'L') || (pClass === 'odaka' && i === moraCount - 1)) {
            span.dataset.pitchNext = 'low';
          }
        }

        const line = document.createElement('span');
        line.className = 'pronunciation-mora-line';
        span.appendChild(line);
        container.appendChild(span);
      }

      rt.innerHTML = '';
      rt.appendChild(container);
    });
  }

  async function ankiConnectRequest(action, params = {}) {
    try {
      const response = await fetch(ankiConnectUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ action, version: 6, params }),
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (data.error) {
        throw new Error(`AnkiConnect error: ${data.error}`);
      }
      return data.result;
    } catch (error) {
      return null;
    }
  }

  async function wrapKanjiInWordField() {
    const wordContainer = document.getElementById("word");
    if (!wordContainer) return;

    const mainSpan = wordContainer.querySelector(':scope > span');
    if (!mainSpan) return;

    const rubyElement = mainSpan.querySelector('ruby');
    if (!rubyElement) return;

    let wordText = '';
    let readingText = '';
    for (const node of rubyElement.childNodes) {
      if (node.nodeName.toLowerCase() === 'rt') {
        readingText = node.textContent.trim();
        const wordNode = node.previousSibling;
        if (wordNode) {
          wordText = wordNode.textContent.trim();
        }
        break;
      }
    }
    if (!readingText) {
        wordText = rubyElement.textContent.trim();
    }

    if (!/[一-龯]/.test(wordText)) {
      return;
    }

    const uniqueKanji = new Set();
    for (const char of wordText) {
      if (isKanji(char)) {
        uniqueKanji.add(char);
      }
    }

    for (const kanji of uniqueKanji) {
      if (preloadedKanjiData[kanji]) continue;

      const query = `note:Senren "word:*${kanji}*"`;
      const noteIds = await ankiConnectRequest("findNotes", { query });

      if (!noteIds || noteIds.length === 0) continue;

      const notesInfo = await ankiConnectRequest("notesInfo", { notes: noteIds });
      const allCardIds = [];
      notesInfo.forEach(n => { if (n.cards && n.cards.length) allCardIds.push(...n.cards); });

      const cardTypeMap = {};
      if (allCardIds.length > 0) {
        const cardsInfo = await ankiConnectRequest("cardsInfo", { cards: allCardIds });
        if (cardsInfo) {
          cardsInfo.forEach(c => cardTypeMap[c.cardId] = c.type);
        }
      }

      if (!notesInfo) continue;

      const relatedWords = [];
      const uniqueWords = new Set();

      for (const note of notesInfo) {
        const fields = note.fields;
        if (fields && fields.word && fields.word.value) {
          const wordValueRaw = fields.word.value;

          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = wordValueRaw;
          const wordValue = tempDiv.textContent || tempDiv.innerText || "";

          if (wordValue.trim() !== wordText && !uniqueWords.has(wordValue.trim())) {
            const readingValueFull = fields.reading ? fields.reading.value : '';
            const sentenceValue = fields.sentence ? fields.sentence.value : '';
            let readingHtml = '';

            if (readingValueFull && readingValueFull.includes('<li')) {
              try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = readingValueFull;
                const firstLi = tempDiv.querySelector('li');
                if (firstLi) {
                  readingHtml = firstLi.innerHTML;
                }
              } catch (e) {
                readingHtml = readingValueFull.split(/[,、・]/)[0].trim();
              }
            } else {
              readingHtml = readingValueFull.split(/[,、・]/)[0].trim();
            }

            const pitchValue = fields.pitch ? fields.pitch.value : '';
            const pitchPositionValue = fields.pitchPosition ? fields.pitchPosition.value : '';
            const tagsValue = fields.Tags ? fields.Tags.value : '';
            const isNewCard = !note.cards.some(cid => cardTypeMap[cid] > 0)

            relatedWords.push({
              word: wordValue,
              reading: readingHtml,
              sentence: sentenceValue,
              pitch: pitchValue,
              pitchPosition: pitchPositionValue,
              tags: tagsValue,
              isNew: isNewCard,
              noteId: note.noteId
            });

            uniqueWords.add(wordValue.trim());
          }
        }
      }
      preloadedKanjiData[kanji] = relatedWords;
    }

    const textContent = wordText;
    const fragment = document.createDocumentFragment();
    let lastIndex = 0;

    for (let i = 0; i < textContent.length; i++) {
      if (isKanji(textContent[i])) {
        if (lastIndex < i) {
          fragment.appendChild(document.createTextNode(textContent.slice(lastIndex, i)));
        }
        const span = document.createElement("span");
        span.textContent = textContent[i];
        span.className = "kanji";
        span.addEventListener("mouseover", () => {
          showKanjiInfo(span);
        });
        span.addEventListener("mouseout", () => {
          hideKanjiInfo();
        });
        fragment.appendChild(span);
        lastIndex = i + 1;
      }
    }

    if (lastIndex < textContent.length) {
      fragment.appendChild(document.createTextNode(textContent.slice(lastIndex)));
    }

    const rtElement = rubyElement.querySelector('rt');
    while (rubyElement.firstChild) {
      rubyElement.removeChild(rubyElement.firstChild);
    }

    rubyElement.appendChild(fragment);
    if (rtElement) {
      rubyElement.appendChild(rtElement);
    }
  }

  function hideKanjiInfo(force = false) {
    if (tooltipElement) {
      clearTimeout(hideTooltipTimeout);
      hideTooltipTimeout = setTimeout(() => {
        const isOverKanji = document.querySelector('.kanji:hover');
        const isOverTooltip = tooltipElement.matches(':hover');

        if (!isOverKanji && !isOverTooltip) {
          tooltipElement.classList.remove('active');
          tooltipElement.style.display = 'none';
        }
      }, force ? 0 : 100);
    }
  }

  async function showKanjiInfo(element) {
    if (!tooltipElement) return;
    clearTimeout(hideTooltipTimeout);
    const kanji = element.textContent;

    tooltipElement.innerHTML = "";

    if (preloadedKanjiData[kanji]) {
      const relatedWords = preloadedKanjiData[kanji];
      let relatedWordsHtml = "<ul class=\"kanji-tooltip-list\">";
      let count = 0;
      const maxInitialWords = 5;

      const kanjiHighlightRegex = new RegExp(kanji.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
      const highlightSpan = `<span class="kanji-highlight">${kanji}</span>`;

      for (const wordInfo of relatedWords) {
        const wordHtml = wordInfo.word.replace(kanjiHighlightRegex, highlightSpan);

        let formattedPositionHtml = '';
        let firstPitchCategory = '';
        let fullCategoriesHtml = '';

        if (wordInfo.pitchPosition) {
          const numbers = Array.from(wordInfo.pitchPosition.matchAll(/\d+/g))
            .map(match => parseInt(match[0], 10))
            .filter((num, index, arr) => arr.indexOf(num) === index);

          let tempRt = null;
          if (wordInfo.reading) {
            const tempReadingDiv = document.createElement('div');
            tempReadingDiv.innerHTML = wordInfo.reading;
            const readingTextContent = tempReadingDiv.textContent || tempReadingDiv.innerText || "";

            if (readingTextContent) {
              tempRt = document.createElement('rt');
              tempRt.textContent = readingTextContent;
            }
          }

          if (numbers.length > 0) {
            const pitchTypesRaw = wordInfo.pitch ? wordInfo.pitch.split(',') : [];
            const relevantPitchTypes = [];

            formattedPositionHtml = numbers.map((num, index) => {
              let pitchType = getPitchType(num, tempRt);
              pitchType = pitchType.split(',')[0].trim();
              relevantPitchTypes.push(pitchType);
              return `<span class="pitch-number ${pitchType}">${num}</span>`;
            }).join('・');

            firstPitchCategory = relevantPitchTypes[0] || '';
            fullCategoriesHtml = relevantPitchTypes.join('<br>');
          } else {
            firstPitchCategory = wordInfo.pitch ? wordInfo.pitch.split(',')[0].trim() : '';
            fullCategoriesHtml = wordInfo.pitch ? wordInfo.pitch.replace(/,/g, '<br>') : '';
          }
        } else {
          firstPitchCategory = wordInfo.pitch ? wordInfo.pitch.split(',')[0].trim() : '';
          fullCategoriesHtml = wordInfo.pitch ? wordInfo.pitch.replace(/,/g, '<br>') : '';
        }

        const newClass = wordInfo.isNew ? 'is-new-card' : '';
        const clickAction = `onclick="ankiConnectRequest('guiBrowse', { query: 'nid:${wordInfo.noteId}' })"`;
        const itemHtml = `
          <li class="${newClass} ${firstPitchCategory || ''}" style="${count >= maxInitialWords ? 'display: none;' : ''}">
            <div class="related-word-container pitch card-a">
              <span class="pitch-info ${firstPitchCategory || ''} ${wordInfo.tags || ''}">
                <ruby>
                  <span class="related-word clickable-word" ${clickAction}>${wordHtml}</span>
                  ${wordInfo.reading ? `<rt>${wordInfo.reading}</rt>` : ''}
                </ruby>
                ${formattedPositionHtml ? `<div class="position">${formattedPositionHtml}</div>` : ''}
                ${firstPitchCategory ? `<div class="categories" data-first-category="${firstPitchCategory}" data-full-categories="${fullCategoriesHtml}">${firstPitchCategory}</div>` : ''}
              </span>
            </div>
            ${wordInfo.sentence ? `<div class="related-sentence">「${wordInfo.sentence}」</div>` : ''}
          </li>
        `;

        relatedWordsHtml += itemHtml;
        count++;
      }
      relatedWordsHtml += "</ul>";

      if (relatedWords.length > maxInitialWords) {
        relatedWordsHtml += `<button class="show-more-btn">Show More (${relatedWords.length - maxInitialWords})</button>`;
      }

      tooltipElement.innerHTML = count === 0 ? "No words found." : relatedWordsHtml;
      drawTooltipPitchLines(tooltipElement);
      tooltipElement.classList.add('active');
      tooltipElement.style.display = 'block';
      positionTooltipNearElement(tooltipElement, element);

      const showMoreBtn = tooltipElement.querySelector('.show-more-btn');
      if (showMoreBtn) {
        showMoreBtn.addEventListener('click', () => {
          const hiddenItems = tooltipElement.querySelectorAll('li[style="display: none;"]');
          hiddenItems.forEach(item => item.style.display = '');
          showMoreBtn.remove();
        });
      }

      tooltipElement.addEventListener('mouseover', () => clearTimeout(hideTooltipTimeout));
      tooltipElement.addEventListener('mouseout', () => hideKanjiInfo());

      tooltipElement.addEventListener('mouseover', (event) => {
        const positionElement = event.target.closest('.position');
        if (positionElement) {
          const categoriesElement = positionElement.nextElementSibling;
          if (categoriesElement && categoriesElement.classList.contains('categories') && categoriesElement.dataset.fullCategories) {
            if (categoriesElement.innerHTML !== categoriesElement.dataset.fullCategories) {
              categoriesElement.innerHTML = categoriesElement.dataset.fullCategories;
            }
          }
        }
      });
    }
  }

  function positionTooltipNearElement(element, targetElement) {
    if (!element || !targetElement) return;

    const parent = element.offsetParent;
    if (!parent) return;

    const targetRect = targetElement.getBoundingClientRect();
    const parentRect = parent.getBoundingClientRect();

    const arrowSize = 7;
    const defaultArrowLeft = 15;

    const relativeTop = targetRect.top - parentRect.top;
    const relativeLeft = targetRect.left - parentRect.left;

    element.style.left = `${relativeLeft}px`;
    element.style.top = `${relativeTop + targetRect.height}px`;
    element.classList.remove('tooltip-above');

    element.style.setProperty('--tooltip-arrow-left', `${targetRect.width / 2}px`);

    const tooltipRect = element.getBoundingClientRect();

    if (tooltipRect.right > window.innerWidth) {
      element.style.left = `${relativeLeft + (window.innerWidth - tooltipRect.right - 10)}px`;
    }

    const finalLeft = parseFloat(element.style.left || '0');
    if (finalLeft + parentRect.left < 0) {
      element.style.left = `${-parentRect.left + 10}px`;
    }

    const bottomBuffer = 10;
    if (tooltipRect.bottom > window.innerHeight - bottomBuffer) {
      const potentialTopAbove = relativeTop - tooltipRect.height - arrowSize;
      if (potentialTopAbove + parentRect.top > 0) {
        element.style.top = `${potentialTopAbove}px`;
        element.classList.add('tooltip-above');
      } else {

        element.classList.remove('tooltip-above');
      }
    } else {
      element.classList.remove('tooltip-above');
    }

    const finalTop = parseFloat(element.style.top || '0');
    if (element.classList.contains('tooltip-above') && (finalTop + parentRect.top < 0)) {
      element.style.top = `${-parentRect.top + 10}px`;
    }

    const finalTooltipLeftRelative = parseFloat(element.style.left || '0');
    let newArrowLeft = defaultArrowLeft;

    const targetCenterRelativeX = relativeLeft + (targetRect.width / 2);
    newArrowLeft = targetCenterRelativeX - finalTooltipLeftRelative;

    const tooltipWidth = element.offsetWidth;
    newArrowLeft = Math.max(arrowSize, Math.min(newArrowLeft, tooltipWidth - arrowSize));
    element.style.setProperty('--tooltip-arrow-left', `${newArrowLeft}px`);
  }

  // Helper function to determine pitch type
  function getPitchType(number, readingElement) {
    if (!readingElement) return 'unknown';

    const firstLi = readingElement.querySelector('li');
    const targetElement = firstLi || readingElement;

    const readingText = (targetElement.textContent || targetElement.innerText || "")
      .replace(/<[^>]+>/g, '')
      .replace(/([ぁ-ゖァ-ヺ])[\u3099\u309A]/g, '$1゙')
      .normalize("NFC")
      .replace(/[ぁぃぅぇぉゃゅょァィゥェォャュョ]/g, '')
      .replace(/[・〜～]/g, '')
      .replace(/\s+/g, '');

    const moraCount = readingText.length;

    if (moraCount === 0) {
      return 'unknown';
    }

    let resultType = 'unknown';
    if (number === 0) resultType = 'heiban';
    if (number === 1) resultType = 'atamadaka';
    if (moraCount > 1 && number === moraCount) resultType = 'odaka';
    if (number > 1 && number < moraCount && resultType === 'unknown') {
      resultType = 'nakadaka';
    }

    return resultType;
  }

  // Format pitch accent positions and categories 
  function cleanPitchPositions() {
    const allSpans = document.querySelectorAll("span");
    allSpans.forEach(spanElement => {
      const classList = spanElement.classList;
      let classToModify = "";
      classList.forEach(cls => {
        if (cls.includes(",")) {
          classToModify = cls;
        }
      });

      if (classToModify) {
        const commaIndex = classToModify.indexOf(",");
        const newClassValue = commaIndex !== -1 ? classToModify.substring(0, commaIndex).trim() : classToModify;
        spanElement.classList.remove(classToModify);
        spanElement.classList.add(newClassValue);
      }
    });

    const positionElements = document.querySelectorAll('#position');
    const rubyElement = document.querySelector("#word > span > ruby");
    const mainWordSpan = document.querySelector("#word > span");
    const sentenceSpan = document.getElementById("formattedSentence");
    const rtElement = rubyElement?.querySelector('rt');

    let potentialFallbackClass = null;
    let runFallbackCheck = false;

    positionElements.forEach(element => {
      if (element.dataset.cleaned || !element.innerHTML.trim()) return;

      const content = element.innerHTML.trim();
      const numbers = Array.from(content.matchAll(/\d+/g))
        .map(match => parseInt(match[0], 10))
        .filter((num, index, arr) => arr.indexOf(num) === index);

      if (numbers.length === 0) return;

      if (!runFallbackCheck && mainWordSpan && rtElement) {
        const hasPitchClass = ['heiban', 'atamadaka', 'nakadaka', 'odaka', 'kifuku']
          .some(cls => mainWordSpan.classList.contains(cls));
        if (!hasPitchClass) {
          const firstNumber = numbers[0];
          const calculatedClass = getPitchType(firstNumber, rtElement);
          if (calculatedClass && calculatedClass !== 'unknown') {
            potentialFallbackClass = calculatedClass;
            runFallbackCheck = true;
          }
        }
      }

      const categoriesElement = element.closest('.pitch')?.querySelector('#categories');
      const pitchTypes = categoriesElement?.textContent.split(',') || [];

      const resolvedPitchTypes = [];
      const newContent = numbers.map((num, index) => {
        let pitchType = pitchTypes[index]?.trim() || getPitchType(num, rtElement);
        let cleanPitchType = pitchType.split(',')[0].trim();
        resolvedPitchTypes.push(cleanPitchType);
        return `<span class="pitch-number ${cleanPitchType}">${num}</span>`;
      }).join('・');

      if (resolvedPitchTypes.length > 0) {
        categoriesElement.dataset.fullCategories = resolvedPitchTypes.join('<br>');
        categoriesElement.innerHTML = resolvedPitchTypes[0];
      } else {
        categoriesElement.dataset.fullCategories = '';
        categoriesElement.innerHTML = '';
      }

      element.innerHTML = newContent;
      element.dataset.cleaned = 'true';
    });

    if (runFallbackCheck && potentialFallbackClass) {
      const hasPitchClassNow = ['heiban', 'atamadaka', 'nakadaka', 'odaka', 'kifuku']
        .some(cls => mainWordSpan.classList.contains(cls));
      if (!hasPitchClassNow) {
        mainWordSpan.classList.add(potentialFallbackClass);
        sentenceSpan.classList.add(potentialFallbackClass);
      }
    }

    positionElements.forEach(pos => {
      const cat = pos.closest('.pitch')?.querySelector('#categories');
      if (cat?.dataset.fullCategories) {
        pos.addEventListener('mouseenter', () => {
          cat.innerHTML = cat.dataset.fullCategories;
        });
      }
    });
  }

  // Highlight the target word in the furigana sentence
  function highlightFurigana() {
    const sentence = `{{sentence}}`;
    let sentenceFurigana = `{{furigana:sentenceFurigana}}`;

    if (!sentenceFurigana.trim()) {
      document.getElementById("formattedSentence").innerHTML = sentence;
      return;
    }

    sentenceFurigana = sentenceFurigana.replace(
      /([\u3005\u4e00-\u9faf]+)\[([^\]]+)\]/g, 
      '<ruby><rb>$1</rb><rt>$2</rt></ruby>'
    );

    sentenceFurigana = sentenceFurigana.replace(
      /<ruby>([^<]+?)<rt>(.*?)<\/rt><\/ruby>/g,
      '<ruby><rb>$1</rb><rt>$2</rt></ruby>'
    );

    let cleanedFurigana = sentenceFurigana
      .replace(/<ruby><rb>([。、！？！？])<\/rb><rt>.*?<\/rt><\/ruby>/g, '$1')
      .replace(/<ruby>([。、！？！？])<rt>.*?<\/rt><\/ruby>/g, '$1');

    if (cleanedFurigana.includes('<span class="highlight">')) {
      document.getElementById("formattedSentence").innerHTML = cleanedFurigana;
      return;
    }

    const highlightRegex = /<span class="highlight">(.*?)<\/span>/g;
    const highlightedWords = [];
    let match;
    while ((match = highlightRegex.exec(sentence)) !== null) {
      highlightedWords.push(match[1]);
    }

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = cleanedFurigana;

    const allNodes = [];

    function collectTextAndRubyNodes(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.length > 0) { 
          allNodes.push({ type: 'text', node: node });
        }
      } else if (node.tagName === 'RUBY') {
        allNodes.push({ type: 'ruby', node: node });
      } else {
        for (let i = 0; i < node.childNodes.length; i++) {
          collectTextAndRubyNodes(node.childNodes[i]);
        }
      }
    }

    collectTextAndRubyNodes(tempDiv);

    let plainText = '';
    const nodePositions = [];

    allNodes.forEach(item => {
      let text;
      if (item.type === 'text') {
        text = item.node.textContent;
      } else {
        const rb = item.node.querySelector('rb') || item.node.firstChild;
        text = rb.textContent;
      }

      nodePositions.push({
        node: item.node,
        type: item.type,
        start: plainText.length,
        end: plainText.length + text.length
      });

      plainText += text;
    });

    highlightedWords.forEach(word => {
      let searchStartIndex = 0;
      let wordStart;
      
      while ((wordStart = plainText.indexOf(word, searchStartIndex)) !== -1) {
        const wordEnd = wordStart + word.length;
        
        const affectedNodes = nodePositions.filter(pos =>
          pos.start < wordEnd && pos.end > wordStart
        );

        affectedNodes.forEach(pos => {
          const node = pos.node;
          if (!node.parentNode) return; 

          const relativeStart = Math.max(0, wordStart - pos.start);
          let relativeEnd = Math.min(pos.end - pos.start, wordEnd - pos.start);
          
          if(pos.type === 'ruby') {
             const rb = node.querySelector('rb') || node.firstChild;
             relativeEnd = Math.min(relativeEnd, rb.textContent.length);
          } else {
             relativeEnd = Math.min(relativeEnd, node.textContent.length);
          }

          if (pos.start >= wordStart && pos.end <= wordEnd) {
            const wrapper = document.createElement('span');
            wrapper.className = 'highlight';
            
            if (pos.type === 'ruby') {
              const clone = node.cloneNode(true);
              wrapper.appendChild(clone);
              node.parentNode.replaceChild(wrapper, node);
            } else {
              wrapper.textContent = node.textContent;
              node.parentNode.replaceChild(wrapper, node);
            }
          } 
          else {
            if (pos.type === 'ruby') {
              const ruby = node;
              const rb = ruby.querySelector('rb') || ruby.firstChild;
              const rt = ruby.querySelector('rt');
              if (!rb || !rt) return;

              const baseText = rb.textContent;
              const rtText = rt.textContent;

              let newHTML = '';

              if (relativeStart > 0) {
                const subRb = baseText.substring(0, relativeStart);
                const subRtLen = Math.round(rtText.length * relativeStart / baseText.length);
                const subRt = rtText.substring(0, subRtLen);
                newHTML += `<ruby><rb>${subRb}</rb><rt>${subRt}</rt></ruby>`;
              }

              const midRb = baseText.substring(relativeStart, relativeEnd);
              const startRtIdx = Math.round(rtText.length * relativeStart / baseText.length);
              const endRtIdx = Math.round(rtText.length * relativeEnd / baseText.length);
              const midRt = rtText.substring(startRtIdx, endRtIdx);
              
              newHTML += `<span class="highlight"><ruby><rb>${midRb}</rb><rt>${midRt}</rt></ruby></span>`;

              if (relativeEnd < baseText.length) {
                const subRb = baseText.substring(relativeEnd);
                const subRt = rtText.substring(endRtIdx);
                newHTML += `<ruby><rb>${subRb}</rb><rt>${subRt}</rt></ruby>`;
              }

              const span = document.createElement('span');
              span.innerHTML = newHTML;
              ruby.parentNode.replaceChild(span, ruby);

            } else {
              const text = node.textContent;
              const beforeText = text.substring(0, relativeStart);
              const highlightedText = text.substring(relativeStart, relativeEnd);
              const afterText = text.substring(relativeEnd);

              const fragment = document.createDocumentFragment();
              if (beforeText) fragment.appendChild(document.createTextNode(beforeText));
              
              const hlSpan = document.createElement('span');
              hlSpan.className = 'highlight';
              hlSpan.textContent = highlightedText;
              fragment.appendChild(hlSpan);
              
              if (afterText) fragment.appendChild(document.createTextNode(afterText));

              node.parentNode.replaceChild(fragment, node);
            }
          }
        });
        searchStartIndex = wordEnd;
      }
    });

    document.getElementById("formattedSentence").innerHTML = tempDiv.innerHTML;
  }

  // Alternative pitch styling based on CSS variables
  function alternativePitchStyle() {
    const rootElement = document.documentElement;
    const computedRootStyle = getComputedStyle(rootElement);

    const wordElement = document.getElementById('word');
    if (wordElement) {
      const pitchStyleValue = computedRootStyle.getPropertyValue('--pitch-style').trim();
      wordElement.classList.toggle('alt', pitchStyleValue === 'alt');

      const pitchColorsValue = computedRootStyle.getPropertyValue('--pitch-colors').trim();
      wordElement.classList.toggle('colors', pitchColorsValue === 'false');
    }

    const sentenceElement = document.getElementById("formattedSentence");
    if (sentenceElement) {
      const sentenceHighlightValue = computedRootStyle.getPropertyValue('--sentence-pitch-highlight').trim();
      sentenceElement.classList.toggle('alt-highlight', sentenceHighlightValue === 'true');
    }
  }

  // Generates a visual pitch accent line using Yomitan-style formatting
  function createDownstepNotation() {
    const wordElement = document.getElementById('word');
    if (!wordElement) return;

    const mainSpan = wordElement.querySelector(':scope > span');
    const rubyElement = mainSpan?.querySelector('ruby');
    let rtElement = rubyElement?.querySelector('rt');

    if ((wordElement.classList.contains('reading-is-word') || (rtElement && !rtElement.textContent.trim())) && rubyElement) {
      const wordSpan = rubyElement.querySelector('span');
      if (wordSpan) {
        rtElement = wordSpan;
      }
    }

    if (!rtElement) {
      return;
    }

    if (rtElement.querySelector('span[style], ol, li')) {
      return;
    }

    const readingText = rtElement.textContent.trim();
    if (!readingText) {
      return;
    }

    const normalizedReading = readingText.normalize("NFC");
    const moraRegexParts = [
      '[きしちにひみりぎじぢびぴゔ][ゃゅょ]',
      '[うくすつぬふむゆるぐずづぶゔ][ぁぃぅぇぉ]',
      '[てで][ぃ]',
      '[とど][ぅ]',
      '[キシチニヒミリギジヂビピヴ][ャュョ]',
      '[ウクスツヌフムユルグズヅブプヴ][ァィゥェォ]',
      '[テデ][ィ]',
      '[トド][ゥ]',
      '[クグ][ヮ]',
      '[フ][ォ]',
      '[っッ]',
      'ー',
      '[んン]',
      '[\u3041-\u3096\u30A1-\u30F6\u30FD\u30FE]',
      '\\S'
    ];
    const moraRegex = new RegExp(moraRegexParts.join('|'), 'g');
    const morae = normalizedReading.match(moraRegex) || [];

    const moraCount = morae.length;
    if (moraCount === 0) return;

    let pitchPosition = -1;
    let pitchClass = '';
    const positionElement = document.getElementById('position');

    const mainClasses = mainSpan.classList;
    const isOriginallyKifuku = mainClasses.contains('kifuku');
    if (mainClasses.contains('heiban')) pitchClass = 'heiban';
    else if (mainClasses.contains('atamadaka')) pitchClass = 'atamadaka';
    else if (mainClasses.contains('nakadaka')) pitchClass = 'nakadaka';
    else if (mainClasses.contains('odaka')) pitchClass = 'odaka';
    else if (isOriginallyKifuku) pitchClass = 'kifuku';

    if (positionElement && positionElement.textContent.trim()) {
      const firstNumMatch = positionElement.textContent.trim().match(/\d+/);
      if (firstNumMatch) {
        pitchPosition = parseInt(firstNumMatch[0], 10);
      }
    }

    if (pitchPosition !== -1) {
      if (pitchPosition === 0) pitchClass = 'heiban';
      else if (pitchPosition === 1) pitchClass = 'atamadaka';
      else if (moraCount > 1 && pitchPosition === moraCount) pitchClass = 'odaka';
      else if (moraCount > 1 && pitchPosition > 1 && pitchPosition < moraCount) pitchClass = 'nakadaka';
      else if (moraCount > 1 && pitchPosition >= moraCount) pitchClass = 'odaka';
      else if (moraCount === 1 && pitchPosition >= 1) pitchClass = 'atamadaka';
      else {
        if (!pitchClass) pitchPosition = -1;
      }
    } else if (pitchClass && pitchClass !== 'kifuku' && pitchClass !== 'nakadaka') {
      if (pitchClass === 'heiban') pitchPosition = 0;
      else if (pitchClass === 'atamadaka') pitchPosition = 1;
      else if (pitchClass === 'odaka') pitchPosition = moraCount;
    }

    if (pitchPosition === -1 && !isOriginallyKifuku && pitchClass !== 'kifuku') {
      return;
    }

    let pitchPattern = [];
    for (let i = 0; i < moraCount; i++) {
      if (pitchPosition === 0) pitchPattern.push(i === 0 ? 'L' : 'H');
      else if (pitchPosition === 1) pitchPattern.push(i === 0 ? 'H' : 'L');
      else {
        if (i === 0) pitchPattern.push('L');
        else if (i < pitchPosition) pitchPattern.push('H');
        else pitchPattern.push('L');
      }
    }

    const fragment = document.createDocumentFragment();
    const container = document.createElement('span');
    container.className = 'pronunciation';

    if (isOriginallyKifuku) {
      container.classList.add('kifuku');
    }
    else if (pitchClass) {
      container.classList.add(pitchClass);
    }

    for (let i = 0; i < morae.length; i++) {
      const mora = morae[i];
      const currentPitch = pitchPattern[i];

      const moraSpan = document.createElement('span');
      moraSpan.className = 'pronunciation-mora';
      moraSpan.textContent = mora;
      moraSpan.dataset.pitch = currentPitch === 'H' ? 'high' : 'low';

      if (currentPitch === 'H' &&
        (
          ((i + 1 < moraCount) && pitchPattern[i + 1] === 'L') ||
          (pitchClass === 'odaka' && i === moraCount - 1)
        )
      ) {
        moraSpan.dataset.pitchNext = 'low';
      }

      const lineSpan = document.createElement('span');
      lineSpan.className = 'pronunciation-mora-line';
      moraSpan.appendChild(lineSpan);

      container.appendChild(moraSpan);
    }

    rtElement.innerHTML = '';
    rtElement.appendChild(container);
    rtElement.style.paddingTop = '';
    rtElement.style.marginBottom = '';
    rtElement.style.position = '';
    rtElement.style.overflow = 'visible';
  }

  // Merge entries from the same dictionary
  function consolidateYomitanGlossaryEntries() {
    const glossaryOuterDiv = document.getElementById('glossary');
    if (!glossaryOuterDiv) return;

    const glossaryBox = glossaryOuterDiv.querySelector('.glossary-box');
    if (!glossaryBox) return;

    const glossarySpan = glossaryBox.querySelector('span');
    if (!glossarySpan) return;

    if (glossarySpan.dataset.consolidated === 'true') return;

    const yomitanGlossaryDivs = glossarySpan.querySelectorAll('div.yomitan-glossary');
    if (yomitanGlossaryDivs.length === 0) return;

    let consolidationHappened = false;

    yomitanGlossaryDivs.forEach(ygDiv => {
      const olElement = ygDiv.querySelector('ol');
      if (!olElement) return;

      const listItems = Array.from(olElement.querySelectorAll('li[data-dictionary]'));
      if (listItems.length === 0) return;

      const groupedItems = {};
      listItems.forEach(li => {
        const dictName = li.getAttribute('data-dictionary');
        if (!dictName) return;
        
        if (!groupedItems[dictName]) {
          groupedItems[dictName] = [];
        }
        groupedItems[dictName].push(li);
      });

      Object.keys(groupedItems).forEach(dictName => {
        const items = groupedItems[dictName];
        
        if (items.length > 1) {
          const firstItem = items[0];
          
          const consolidatedLi = firstItem.cloneNode(false);
          
          const combinedHtml = items
            .map(li => li.innerHTML.trim())
            .join('<hr class="consolidated-entry-separator">');
            
          consolidatedLi.innerHTML = combinedHtml;

          olElement.replaceChild(consolidatedLi, firstItem);

          for (let i = 1; i < items.length; i++) {
            olElement.removeChild(items[i]);
          }

          consolidationHappened = true;
        }
      });
    });

    if (consolidationHappened) {
      glossarySpan.dataset.consolidated = 'true';
    }
  }

  // Replaces the word with its reading when the word is written only in kana
  function noDuplicateKana() {
    const substituteSetting = getComputedStyle(document.documentElement).getPropertyValue('--no-duplicate-kana').trim().toLowerCase();

    if (substituteSetting !== 'true') {
      return;
    }

    const rubyElement = document.querySelector("#word ruby");
    if (!rubyElement) return;

    const rtElement = rubyElement.querySelector("rt");
    let wordTextNode = null;
    for (const node of rubyElement.childNodes) {
      if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
        wordTextNode = node;
        break;
      }
    }

    if (!wordTextNode || !rtElement) return;

    const word = wordTextNode.textContent.trim();
    const hasKanji = /[一-龯]/.test(word);

    if (!hasKanji) {
      let readingHTML = '';
      const firstLi = rtElement.querySelector("li");

      if (firstLi) {
        readingHTML = firstLi.innerHTML;
      } else {
        readingHTML = rtElement.innerHTML;
      }

      if (readingHTML.trim()) {
        const readingWrapper = document.createElement('span');
        readingWrapper.innerHTML = readingHTML;

        rubyElement.replaceChild(readingWrapper, wordTextNode);
        
        rtElement.style.display = "none";

        document.getElementById('word').classList.add('reading-is-word');
      }
    }
  }

  // Collapses long dictionary entries and adds a clickable fade-out.
  function collapseDictionary(container) {
    const isCollapsedEnabled = getComputedStyle(document.documentElement)
      .getPropertyValue('--dictionary-collapse')
      .trim();
    if (isCollapsedEnabled !== '1') {
      return;
    }

    if (!container || container.dataset.expanded === 'true') {
      return;
    }

    const rootStyles = getComputedStyle(document.documentElement);
    const maxHeight = parseInt(rootStyles.getPropertyValue('--dictionary-max-height').trim(), 10);

    const oldFade = container.querySelector('.fade-to-show-more');
    if (oldFade) oldFade.remove();
    container.classList.remove('is-collapsed');

    if (container.scrollHeight > maxHeight) {
      container.classList.add('is-collapsed');

      const fadeElement = document.createElement('div');
      fadeElement.className = 'fade-to-show-more tappable';
      container.appendChild(fadeElement);

      fadeElement.addEventListener('click', (e) => {
        e.stopPropagation();
        container.classList.remove('is-collapsed');
        container.dataset.expanded = 'true';
        fadeElement.remove();
      });
    }
  }

  // Groups text, audio, and images into navigable scenes
  function enableSceneSwitching() {
    if (window.currentSceneKeyHandler) {
      document.removeEventListener('keydown', window.currentSceneKeyHandler);
      window.currentSceneKeyHandler = null;
    }

    const audioContainer = document.querySelector('.sentenceaudio');
    const audioParts = audioContainer ? Array.from(audioContainer.children) : [];

    if (audioParts.length <= 1) {
      return;
    }

    const baseWaitTime = 100;  
    const timePerChar = 150;  

    const wordEl = document.getElementById('word');
    let charCount = 5;

    if (wordEl) {
      const rt = wordEl.querySelector('rt');
      const targetElement = (rt && rt.querySelector('li')) ? rt.querySelector('li') : (rt || wordEl);
      
      let rawText = targetElement.textContent;
      let cleanedText = rawText.replace(/[\s\u3099\u309A\u309B\u309C]/g, '');

      cleanedText = cleanedText.replace(/[ぁぃぅぇぉゃゅょゎァィゥェォャュョヮ]/g, '');

      let effectiveCount = cleanedText.length;

      const narrowVowelRegex = /[いきしちにひみりぎじぢびぴイキシチニヒミリギジヂビピうくすつぬふむるぐずづぶぷウクスツヌフムルグズヅブプ]/g;
      const narrowMatches = cleanedText.match(narrowVowelRegex);
      
      if (narrowMatches) {
        effectiveCount -= (narrowMatches.length * 0.3);
      }

      charCount = Math.round(effectiveCount);
      
      if (charCount < 1) charCount = 1;
    }

    let SENTENCE_DELAY;

    if (charCount === 2) SENTENCE_DELAY = 550; 
    else if (charCount === 3) SENTENCE_DELAY = 650;
    else if (charCount === 4) SENTENCE_DELAY = 700;
    else if (charCount === 5) SENTENCE_DELAY = 850;
    else if (charCount === 6) SENTENCE_DELAY = 1000;
    else if (charCount === 7) SENTENCE_DELAY = 1080; 
    else if (charCount === 8) SENTENCE_DELAY = 1150; 
    else SENTENCE_DELAY = baseWaitTime + (charCount * timePerChar);

    let initialPlayTimeout;

    const backContainer = document.querySelector('.back');
    let newArrows = [];

    if (backContainer) {
      const arrowLeft = document.createElement('div');
      arrowLeft.className = 'sentence-nav left';
      backContainer.appendChild(arrowLeft);

      const arrowRight = document.createElement('div');
      arrowRight.className = 'sentence-nav right';
      backContainer.appendChild(arrowRight);

      newArrows = [arrowLeft, arrowRight];
    } else {
      return;
    }

    // Sentence Group
    const sentenceContainer = document.querySelector('.sentence-container #formattedSentence');
    if (sentenceContainer && !sentenceContainer.getAttribute('data-split-done')) {
      const groupWrappers = Array.from(sentenceContainer.querySelectorAll('.group'))
                                .filter(el => el.textContent.trim().length > 0);

      if (groupWrappers.length > 0) {
        const parts = groupWrappers.map(el => el.outerHTML);
        sentenceContainer.innerHTML = '';
        parts.forEach((partHTML) => {
          const div = document.createElement('div');
          div.classList.add('split-sentence');
          div.innerHTML = partHTML;
          div.style.display = 'none';
          sentenceContainer.appendChild(div);
        });
        sentenceContainer.setAttribute('data-split-done', 'true');
      }
    }

    // Sentence Eng Group
    const engContainer = document.getElementById('sentenceEng');
    if (engContainer && !engContainer.getAttribute('data-split-done')) {
      const allSpans = Array.from(engContainer.querySelectorAll('span'));
      const groupWrappers = allSpans.filter(el => {
         return el.className.split(/\s+/).some(c => /^group\d*$/.test(c));
      });

      if (groupWrappers.length > 0) {
        engContainer.innerHTML = '';
        
        groupWrappers.forEach((el) => {
          const div = document.createElement('div');
          div.classList.add('split-sentence-eng');
          div.innerHTML = el.outerHTML;
          div.style.display = 'none';

          const match = el.className.match(/group(\d+)/);
          if (match) {
             div.setAttribute('data-target-index', parseInt(match[1], 10) - 1);
          }

          engContainer.appendChild(div);
        });
        engContainer.setAttribute('data-split-done', 'true');
      }
    }

    // Misc Info Group
    const miscInfoContainer = document.querySelector('.misc-info'); 
    
    if (miscInfoContainer && !miscInfoContainer.getAttribute('data-split-done')) {
      const allSpans = Array.from(miscInfoContainer.querySelectorAll('span'));
      const groupWrappers = allSpans.filter(el => {
         return el.className.split(/\s+/).some(c => /^group\d*$/.test(c));
      });

      if (groupWrappers.length > 0) {
        miscInfoContainer.innerHTML = '';
        
        groupWrappers.forEach((el) => {
          const div = document.createElement('div');
          div.classList.add('split-misc-info');
          div.innerHTML = el.outerHTML;
          div.style.display = 'none';

          const match = el.className.match(/group(\d+)/);
          if (match) {
             div.setAttribute('data-target-index', parseInt(match[1], 10) - 1);
          }

          miscInfoContainer.appendChild(div);
        });
        miscInfoContainer.setAttribute('data-split-done', 'true');
      }
    }

    const sentenceParts = document.querySelectorAll('.sentence-container #formattedSentence .split-sentence');
    const engParts = document.querySelectorAll('#sentenceEng .split-sentence-eng'); 
    const miscInfoParts = document.querySelectorAll('.misc-info .split-misc-info'); 
    const images = document.querySelectorAll('.picture-container img.field-img');

    let totalSlides = 1;
    if (audioParts.length > 0) {
        totalSlides = audioParts.length;
    }

    let currentIndex = 0;

    function playActiveAudio() {
      if (audioParts.length === 0) return;

      document.querySelectorAll('audio').forEach(a => {
        try { a.pause(); a.currentTime = 0; } catch(e){}
      });

      let audioToPlay = null;
      if (audioParts.length === 1) {
        audioToPlay = audioParts[0];
      } else if (audioParts[currentIndex]) {
        audioToPlay = audioParts[currentIndex];
      }

      if (audioToPlay) {
        audioToPlay.click();
      }
    }

    let replayTimeout; 

    const handleSceneShortcuts = (e) => {
        if (document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

        const rootStyle = getComputedStyle(document.documentElement);
        const cssVal = rootStyle.getPropertyValue('--scene-replay-shortcut-key').trim();

        const replayConfig = parseKeyConfig(cssVal) || { key: 'w', ctrl: false, alt: false, shift: false, meta: false };

        if (isKeyMatch(e, replayConfig)) { 
            e.preventDefault();
            e.stopPropagation();

            if (replayTimeout) clearTimeout(replayTimeout);
            if (typeof initialPlayTimeout !== 'undefined') clearTimeout(initialPlayTimeout);

            document.querySelectorAll('audio').forEach(a => {
                try { a.pause(); a.currentTime = 0; } catch(e){}
            });

            const wordAudioBtn = document.querySelector('.audio .soundLink, .audio .replaybutton');
            if (wordAudioBtn) {
                wordAudioBtn.click();
            }

          replayTimeout = setTimeout(() => {
                playActiveAudio(); 
          }, SENTENCE_DELAY);
        }

        if (e.ctrlKey) {
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                e.stopPropagation();
                if (typeof initialPlayTimeout !== 'undefined') clearTimeout(initialPlayTimeout);

                currentIndex--;
                if (currentIndex < 0) currentIndex = totalSlides - 1;
                updateDisplay(true);
            } 
            else if (e.key === 'ArrowRight') {
                e.preventDefault();
                e.stopPropagation();
                if (typeof initialPlayTimeout !== 'undefined') clearTimeout(initialPlayTimeout);

                currentIndex++;
                if (currentIndex >= totalSlides) currentIndex = 0;
                updateDisplay(true);
            }
        }
    };

    window.currentSceneKeyHandler = handleSceneShortcuts;
    document.addEventListener('keydown', handleSceneShortcuts);

    function updateDisplay(shouldPlayAudio = false) {
      const currentFieldImages = document.querySelectorAll('.picture-container img');
      
      if (currentFieldImages.length > 0) {
        let indexToShow = 0;
        if (currentFieldImages.length > 1) {
            indexToShow = Math.min(currentIndex, currentFieldImages.length - 1);
        }
        const targetImage = currentFieldImages[indexToShow];

        const allImagesInContainer = document.querySelectorAll('.picture-container img');
        allImagesInContainer.forEach(img => {
            img.style.setProperty('display', 'none', 'important');
        });

        if (targetImage) {
            targetImage.style.setProperty('display', 'block', 'important');
        }
      }

      if (sentenceParts.length > 0) {
        sentenceParts.forEach((part, i) => {
          const shouldShow = (sentenceParts.length === 1) || (i === currentIndex);
          part.style.display = shouldShow ? 'block' : 'none';
        });
      }


      const mainMiscContainer = document.querySelector('.misc-info');
      if (miscInfoParts.length > 0) {
        let isAnyChildVisible = false;

        miscInfoParts.forEach((part, i) => {
          let shouldShow = false;

          if (part.hasAttribute('data-target-index')) {
             const targetIndex = parseInt(part.getAttribute('data-target-index'), 10);
             shouldShow = (targetIndex === currentIndex);
          } 
          else {
             if (miscInfoParts.length === 1) {
                 shouldShow = (currentIndex === 0);
             } else {
                 shouldShow = (i === currentIndex);
             }
          }

          if (shouldShow) {
              part.style.setProperty('display', 'flex', 'important');
              isAnyChildVisible = true;
          } else {
              part.style.setProperty('display', 'none', 'important');
          }
        });

        if (mainMiscContainer) {
            const displayValue = isAnyChildVisible ? 'flex' : 'none';
            mainMiscContainer.style.setProperty('display', displayValue, 'important');
        }

      } else if (mainMiscContainer) {
        if (currentIndex === 0) {
            mainMiscContainer.style.setProperty('display', 'flex', 'important');
        } else {
            mainMiscContainer.style.setProperty('display', 'none', 'important');
        }
      }

      const mainEngContainer = document.getElementById('sentenceEng');
      if (engParts.length > 0) {
        engParts.forEach((part, i) => {
          let shouldShow = false;

          if (part.hasAttribute('data-target-index')) {
             const targetIndex = parseInt(part.getAttribute('data-target-index'), 10);
             shouldShow = (targetIndex === currentIndex);
          } 
          else {
             if (engParts.length === 1) {
                 shouldShow = (currentIndex === 0);
             } else {
                 shouldShow = (i === currentIndex);
             }
          }

          part.style.display = shouldShow ? 'flex' : 'none';
        });

        if (mainEngContainer) mainEngContainer.style.display = 'flex';

      } else if (mainEngContainer) {
        mainEngContainer.style.display = (currentIndex === 0) ? 'flex' : 'none';
      }

      if (audioParts.length > 0) {
        audioParts.forEach((btn, i) => {
          const shouldShow = (audioParts.length === 1) || (i === currentIndex);
          if (shouldShow) {
              btn.style.setProperty('display', 'inline-block', 'important');
          } else {
              btn.style.setProperty('display', 'none', 'important');
          }
        });
      }

      if (shouldPlayAudio) {
        playActiveAudio();
      }
    }

    newArrows.forEach(arrow => {
      arrow.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();

        if (initialPlayTimeout) clearTimeout(initialPlayTimeout);

        const direction = arrow.classList.contains('left') ? -1 : 1;
        currentIndex += direction;

        if (currentIndex >= totalSlides) {
          currentIndex = 0;
        } else if (currentIndex < 0) {
          currentIndex = totalSlides - 1;
        }

        updateDisplay(true); 
      });
    });
    
    updateDisplay(false); 

    const muteNsfw = getComputedStyle(document.documentElement)
      .getPropertyValue('--mute-nsfw-audio')
      .trim()
      .toLowerCase();

    if (muteNsfw === 'true') {
    } else {
       initialPlayTimeout = setTimeout(() => {
         playActiveAudio();
       }, SENTENCE_DELAY);
    }
  }

  // Marks the original Anki images
  function markFieldImages() {
    const images = document.querySelectorAll('.picture-container > img');
    images.forEach(img => {
      img.classList.add('field-img');
    });
  }

  // Enables custom shortcuts
  function enableCustomShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (document.activeElement && ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

      const rootStyle = getComputedStyle(document.documentElement);
      
      const lightboxConfig = parseKeyConfig(rootStyle.getPropertyValue('--toggle-picture-lightbox-key').trim());
      const gridConfig = parseKeyConfig(rootStyle.getPropertyValue('--toggle-picture-lightbox-grid-key').trim());

      if (isKeyMatch(e, gridConfig)) {
        e.preventDefault();
        e.stopPropagation();

        const lightbox = document.getElementById("lightbox");
        const showAllBtn = document.getElementById("show-all");

        if (lightbox && !lightbox.classList.contains("active")) {
             const visibleImage = document.querySelector('.picture-container img[style*="display: block"]') 
                               || document.querySelector('.picture-container img');
             if (visibleImage) visibleImage.click();
             
             if (showAllBtn) showAllBtn.click();
        } 
        else if (lightbox && lightbox.classList.contains("active")) {
             if (showAllBtn) showAllBtn.click();
        }
        return;
      }

      if (isKeyMatch(e, lightboxConfig)) {
        e.preventDefault();
        
        const lightbox = document.getElementById("lightbox");
        
        if (lightbox && lightbox.classList.contains("active")) {
          lightbox.classList.remove("active");
          
          const grid = document.querySelector(".lightbox-grid");
          if(grid) grid.remove();
          const showAll = document.getElementById("show-all");
          if(showAll) showAll.textContent = "Show All";
          const lightboxImg = document.getElementById("lightbox-img");
          if(lightboxImg) lightboxImg.style.display = "block";
          const navs = document.querySelectorAll(".lightbox-nav");
          navs.forEach(n => n.style.display = "");
        } 
        else {
          const images = document.querySelectorAll('.picture-container img');
          let visibleImage = Array.from(images).find(img => window.getComputedStyle(img).display !== 'none');
          if (!visibleImage && images.length > 0) visibleImage = images[0];

          if (visibleImage) {
            visibleImage.click();
          }
        }
      }
      
      const dmConfig = parseKeyConfig(rootStyle.getPropertyValue('--toggle-custom-dark-mode-key').trim());
      if (isKeyMatch(e, dmConfig)) {
         e.preventDefault();
         const dmBtn = document.querySelector(".toggle-custom-dark-mode");
         if (dmBtn) dmBtn.click();
      }
    });
  }

  // Initializes immediate functions
  function init() {
    nsfw();
    muteSentence();
    markFieldImages(); 
    noDuplicateKana();
    splitTags();
    highlightFurigana();
    cleanPitchPositions();
    createDownstepNotation();
    dynamicWordSize();
    alternativePitchStyle();

    // Enable lazy-loading for all images inside #glossary
    document.querySelectorAll('#glossary img').forEach(img => {
      img.setAttribute('loading', 'lazy');
    });

    requestAnimationFrame(() => {
      dictionaryTitle();
      collectGlossaryImages();
      consolidateYomitanGlossaryEntries();
      toggleDefinition();
      enableInteractions();
      enableSceneSwitching(); 
    });
  }

  // initializes deferred functions
  function initDeferred() {
    jitendexHover();
    enableImageSwitching();
    enableLightbox();
    enableCustomShortcuts();

    const isMobile = document.documentElement.classList.contains('mobile') || document.body.classList.contains('mobile');
    if (!isMobile) {
      wrapKanjiInWordField();
    }

    // Prevent specified image links from opening
    document.querySelectorAll('a[target="_blank"][href*="yomitan_dictionary_media_"]').forEach(link => {
      if (link.href && /\.(png|jpe?g|gif|webp|svg)$/i.test(link.href)) link.onclick = e => e.preventDefault();
    });
  }

  init();
  setTimeout(initDeferred, 0);
</script>
